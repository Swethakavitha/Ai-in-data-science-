import heapq

class AStar:
    def __init__(self, grid, start, goal):
        self.grid = grid  # The grid representing the map (2D list)
        self.start = start  # Starting position (x, y)
        self.goal = goal  # Goal position (x, y)
        self.rows = len(grid)
        self.cols = len(grid[0])
        self.open_list = []  # Priority queue
        self.closed_list = set()  # Set of evaluated nodes
        self.came_from = {}  # Path reconstruction
        self.g_score = {}  # Cost from start to current node
        self.f_score = {}  # Estimated total cost (g + h)

    def heuristic(self, a, b):
        # Using Manhattan distance as the heuristic (you can use Euclidean as well)
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def get_neighbors(self, node):
        # Get the valid neighboring nodes (4-directional movement: up, down, left, right)
        neighbors = []
        x, y = node
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < self.rows and 0 <= ny < self.cols and self.grid[nx][ny] != 1:
                neighbors.append((nx, ny))
        
        return neighbors

    def reconstruct_path(self, current):
        # Reconstruct the path from goal to start by following the 'came_from' map
        path = []
        while current in self.came_from:
            path.append(current)
            current = self.came_from[current]
        path.append(self.start)
        return path[::-1]  # Reverse the path to get it from start to goal

    def a_star(self):
        # Initialize the starting node
        heapq.heappush(self.open_list, (0, self.start))  # Push (f_score, node)
        self.g_score[self.start] = 0
        self.f_score[self.start] = self.heuristic(self.start, self.goal)

        while self.open_list:
            _, current = heapq.heappop(self.open_list)

            if current == self.goal:
                # Reconstruct the path and return it
                return self.reconstruct_path(current)

            self.closed_list.add(current)

            for neighbor in self.get_neighbors(current):
                if neighbor in self.closed_list:
                    continue

                tentative_g_score = self.g_score[current] + 1  # Assuming cost between nodes is 1

                if neighbor not in [item[1] for item in self.open_list]:
                    heapq.heappush(self.open_list, (self.f_score.get(neighbor, float('inf')), neighbor))
                elif tentative_g_score >= self.g_score.get(neighbor, float('inf')):
                    continue

                # This path to the neighbor is the best so far, so record it
                self.came_from[neighbor] = current
                self.g_score[neighbor] = tentative_g_score
                self.f_score[neighbor] = self.g_score[neighbor] + self.heuristic(neighbor, self.goal)

        return None  # If no path is found


# Example grid:
# 0 - Free space
# 1 - Blocked cell (obstacle)
grid = [
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

start = (0, 0)  # Start position (top-left corner)
goal = (4, 4)  # Goal position (bottom-right corner)

# Create A* object and find the shortest path
a_star_solver = AStar(grid, start, goal)
path = a_star_solver.a_star()

if path:
    print("Path found:", path)
else:
    print("No path found.")
